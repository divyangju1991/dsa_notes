1. Linear Search => O(n)
2. Binary Search => O(logn)
3. Sorting Algorithms 
   Bubble Sort => O(n^2)
   Insertion Sort => O(n^2)
   Quick Sort => O(nlogn)
   Merge Sort => O(nlogn)
4. Kadane's Algorithm => O(n)
5. Two Pointers Technique => O(n)
6. Check if Array Is Sorted and Rotated => O(n)
   1. count unsorted elements O to n-2 (i.e i<n-1 && nCount < 2)
   2. n > 1 && nums[n-1] > nums[0] then increment nCount. (checking last element and first element)
   3. return nCount < 2
7. Remove Duplicates from Sorted Array => O(n)
   Maintain index for nonDuplicatate and return count of nonDuplicatate elements
8. Reversal algorithm use for rotate the array to the left or right by k steps. => O(n)
   One of the algorithms for array rotation is the reversal algorithm. 
   In this algorithm, subarrays are created 
   and reversed to perform the rotation of the array. 
   Subarrays are created, rotated individually and 
   then joined together and reversed back to get the rotated array
   
   do partition of the array without any space and reverse both partition
   and now reverse entire array.
   
   rotate left partition => 0 to d-1 and d to n-1
   rotate right partition => 0 to n-d-1 and n-d to n-1    
9. Move Zeroes
   1. Count nonZeros and assign in-place nonZero element with nonZero index variable. (a[nNonZero++] = a[i] IF a[i] != 0)
   2. start index from nonZero count to n and set to zeros.
10. Find the Union
    Here we took advantages of sorted elements in two array.
	Use Two point approach.
	in other data structure, fill reamining elements.
	Extra Note : Please make sure that while store arr1 and arr2 and i and j fill appropriatly
11. Find missing number in an array
    use Xor Solution.
	maths solution : total -sum.
	total = n * (n-1) / 2. Equation of natural numbers sum
12. Max Consecutive Ones
    IF current is 1 then increment count else assigne count as 0. Maitain max Count.
13. Find that single one. (ODD find) every element appears twice except for one. 
    use xor approach

15. Longest Sub-Array with Sum K with Postive and Negative
    1. Maintain current sum
	2. If sum == k then consider it as possible solution and put in maxLen. (Note : i+1 = len)
	3. find remaining element sum by rem = sum - k
	4. if rem present in map then consider it possible answer and put it maxLen. (Note len = i - map.get(rem))
	5. If sum is not present in map then only store sum in map as Key and store index as value. (map.put(sum, i))
16. Longest Sub-Array with Sum K with Postive only
    1. Take 2 pointers left and right and initialize long sum = a[0];  int left = 0, right = 0; int maxLen = 0;
	2. do while loop untill right < n
	3. if sum > k, reduce the subarray from left
	               until sum becomes less or equal to k: [e.g while (left <= right && sum > k)]
				sum -= a[left];
                left++;
	4. if sum = k, update the maxLen [e.g len = right - left + 1]
    5. Move forward thw right pointer: 
		right++;
		if (right < n) 
			sum += a[right];	
17. Two Sum Problem
    
	Time Complexity: O(N)
	Space Complexity : O(N)
	HashMap Solution => store current element as key and store index as value. 
	targetSum - current present in map then got 2 elements for given targetSum value.
	
	Please Note : Below solution If and If works If asked for boolean value means 
	two sum exist or not only check or found two element value 
	since after sorting It will change the index so
	found the index is not possible.
	
	here after sorting the array follow problem 18's solution
	
	Time Complexity: O(N) + O(N*logN)
	Space Complexity : O(1)	
18. Two Sum Problem IF Array is sorted
	Time Complexity: O(logN)
	Space Complexity : O(1)

	1. Find rem = target - nums[i] at each element
	2. find rem index using binary search algorithm. [left = i+1, right = n-1, searchKey = rem]
	3. If rem index > 0 print or return the answer	
19. Sort an array of 0's 1's and 2's
	Time Complexity: O(2n)
	Space Complexity: O(1)
	count 0's and 1's and 2's
	
	Please note always below optimum approach
	Using 3 pointers
	Time Complexity: O(n)
	Space Complexity: O(1)
	1. take 3 pointers low = 0, mid = 0, high = n - 1;
	2. do loop until mid <= high
	   If element at mid index found as 0 then swapping arr[low] and arr[mid]
	   low++;
       mid++;
	3. Else If element at mid index found as 1 then mid++;
	4. Else
	   swapping arr[mid] and arr[high]
	   high--;	   
20. Majority Element (>n/2 times)
	Time Complexity : O(NLogN) + O(N)
	Space Complexity : O(N)
	Using HashMap - create a frequency map and iterate untill get element which ocuurs > n/2 times
	(Note : map.put(v[i], mpp.getOrDefault(v[i], 0)+1))
	
	Time complexity O(n*lg(n)) + O(N)
	Space Complexity O(1)
	Using Sorting Algoritm - sort the array and count element untill get element which ocuurs > n/2 times

	moore's voting algorithm
	If count == 0 then consider current element as Majority Element
	Else If current element match with Majority Element then increase count
	else decrease count
	
	Now check Majority Element count is n/2 or not
21. Kadaneâ€™s Algorithm (Maximum Subarray with Postive and Negative Element content)
	For Reference https://medium.com/@rsinghal757/kadanes-algorithm-dynamic-programming-how-and-why-does-it-work-3fd8849ed73d
	1. sum = 0; max = Integer.MIN_VALUE;
	2. sum = Math.max(nums[i], sum+nums[i]);
22. Print subarray with maximum subarray.
    find maximum sum of smallest and second smallest elements chosen from all possible sub-arrays
	Please Note here also mentioned sub array so Loop 0 to N-1 and Math.max(res, arr[i]+arr[i+1]);	
23. Best Time to Buy and Sell Stock
1. intialize minPrice = 0, maxProfit = 0
2. at each level contain minPrice and maxProfit (Math.max(maxProfit, prices[i] - minPrice))
24. Rearrange Array Elements by Sign


   
3. Product of Array Except Self: Given an array of integers, return an array where each element is the product of all the elements in the original array except itself.

4. Container With Most Water: Given an array of non-negative integers representing the heights of vertical lines, find two lines that together with the x-axis form a container that holds the most water.

7. Merge Intervals: Given a collection of intervals, merge any overlapping intervals.

8. Next Permutation: Implement the next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers.

9. Trapping Rain Water: Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it can trap after raining.

10. Median of Two Sorted Arrays: Given two sorted arrays, find the median element of the combined array without merging the arrays.

11. Array Partition I: Given an array of 2n integers, group them into n pairs, such that the sum of each pair is maximized.

https://www.geeksforgeeks.org/top-50-array-coding-problems-for-interviews/

https://workat.tech/company/google/interview-questions/problem-solving?page=2

https://takeuforward.org/strivers-a2z-dsa-course/strivers-a2z-dsa-course-sheet-2/

